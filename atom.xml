<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuangheheTech</title>
  
  
  <link href="https://hehehuang.github.io/atom.xml" rel="self"/>
  
  <link href="https://hehehuang.github.io/"/>
  <updated>2022-12-20T14:53:25.130Z</updated>
  <id>https://hehehuang.github.io/</id>
  
  <author>
    <name>Huang He</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Automation</title>
    <link href="https://hehehuang.github.io/2022/12/06/Python-Automation/"/>
    <id>https://hehehuang.github.io/2022/12/06/Python-Automation/</id>
    <published>2022-12-06T14:17:08.000Z</published>
    <updated>2022-12-20T14:53:25.130Z</updated>
    
    <content type="html"><![CDATA[<p>python 自动化 操作文档</p><p>word</p><p>PPT</p><p>excel</p><p>scape</p><p>tomorrow</p><p>the redirect path</p><p>只管去做：</p><p>为什么会焦虑？</p><p>小强升职记</p><p>项目与习惯</p><p>需求分析哈哈哈</p><p>tian thing</p><p>eee timing is all right</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;python 自动化 操作文档&lt;/p&gt;
&lt;p&gt;word&lt;/p&gt;
&lt;p&gt;PPT&lt;/p&gt;
&lt;p&gt;excel&lt;/p&gt;
&lt;p&gt;scape&lt;/p&gt;
&lt;p&gt;tomorrow&lt;/p&gt;
&lt;p&gt;the redirect path&lt;/p&gt;
&lt;p&gt;只管去做：&lt;/p&gt;
&lt;p&gt;为什么会焦虑？&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Requirement Analysis</title>
    <link href="https://hehehuang.github.io/2022/12/03/Requirement-Analysis/"/>
    <id>https://hehehuang.github.io/2022/12/03/Requirement-Analysis/</id>
    <published>2022-12-03T12:17:52.000Z</published>
    <updated>2022-12-05T13:44:11.570Z</updated>
    
    <content type="html"><![CDATA[<p>requirement analysis</p><p>怎么做需求？</p><p>需求分析</p><p>大话软件工程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;requirement analysis&lt;/p&gt;
&lt;p&gt;怎么做需求？&lt;/p&gt;
&lt;p&gt;需求分析&lt;/p&gt;
&lt;p&gt;大话软件工程&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Learning Method</title>
    <link href="https://hehehuang.github.io/2022/11/28/Learning-Method/"/>
    <id>https://hehehuang.github.io/2022/11/28/Learning-Method/</id>
    <published>2022-11-28T02:45:55.000Z</published>
    <updated>2022-11-28T04:19:29.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习究竟是什么？"><a href="#学习究竟是什么？" class="headerlink" title="学习究竟是什么？"></a>学习究竟是什么？</h2><h4 id="刻意练习："><a href="#刻意练习：" class="headerlink" title="刻意练习："></a>刻意练习：</h4><h5 id="1-学习区练习"><a href="#1-学习区练习" class="headerlink" title="1.学习区练习"></a>1.学习区练习</h5><ul><li>85%熟悉的+15%不知道的知识</li><li>舒适区-&gt;学习区-&gt;恐慌区</li></ul><h5 id="2-切成小块重复练习"><a href="#2-切成小块重复练习" class="headerlink" title="2.切成小块重复练习"></a>2.切成小块重复练习</h5><ul><li>列出所有知识点，一个个练习，学会了就转入下一个</li><li>基础训练，训练套路：比如：编程中的数据结构</li><li>专家：用短时记忆调取自己无限的长期记忆</li></ul><h5 id="3-整个学习，随时获得有效反馈"><a href="#3-整个学习，随时获得有效反馈" class="headerlink" title="3.整个学习，随时获得有效反馈"></a>3.整个学习，随时获得有效反馈</h5><ul><li>自己调研相关知识</li><li>独立或者跟人合作完成项目</li><li>写论文</li></ul><h5 id="4-练习时，注意力高度集中"><a href="#4-练习时，注意力高度集中" class="headerlink" title="4.练习时，注意力高度集中"></a>4.练习时，注意力高度集中</h5><ul><li>番茄钟</li><li>间隔、测验和建立连接。<ul><li>ANKI： 安排间隔，不要突击</li><li>不同场景，不同方式学同一个内容</li><li>参加测验</li><li>新旧知识连接</li></ul></li></ul><h4 id="思维模式："><a href="#思维模式：" class="headerlink" title="思维模式："></a>思维模式：</h4><h5 id="成长性思维："><a href="#成长性思维：" class="headerlink" title="成长性思维："></a>成长性思维：</h5><p>任务是学习的机会，努力，什么事情都是能做成的</p><h5 id="交叉学习："><a href="#交叉学习：" class="headerlink" title="交叉学习："></a>交叉学习：</h5><p>储存记忆+提取记忆：提取强度越用越高。每一次提取记忆，提取强度都会增加。 交叉着在同一时期内学习几门课程，比学完一门再学一门的效果好得多。读书也是这样。我们应该随时都有好几本书在读。</p><h4 id="“自学”的学问"><a href="#“自学”的学问" class="headerlink" title="“自学”的学问"></a>“自学”的学问</h4><p>（1）自学于文本。自学成败的关键，在于你是否善于处理文本信息。我们可以把文本功夫分成三级。</p><p>第一级，是阅读一段文字，或者听一节课，你能不能抓住它的要点。这是基本功，练习这个功夫的方法是<strong>记笔记</strong>。</p><p>第二级，是有一个问题，你能不能从一堆书里找到答案。</p><p>第三级，是建立自己的系统。</p><p>（2）自学于操作理论和实践结合，把学到的东西及时在实践中反复纠错、强化，达到深刻理解和使用。</p><p>（3）从自学到精通一个需要啥就能学啥，学啥就能会啥的人，必定是一个高自尊的人。他对生活有强烈的掌控感，无所畏惧，游刃有余，宠辱不惊。</p><h4 id="强力研读笔记法"><a href="#强力研读笔记法" class="headerlink" title="强力研读笔记法"></a><strong>强力研读笔记法</strong></h4><p>读书笔记的一个重大作用是给自己日后以最快的速度重温这本书提供方便，直接看笔记就可以了。强力研读要求读书笔记必须包括四方面的内容：第一，清晰表现每一章的逻辑脉络；第二，带走书中所有的亮点；第三，大量自己的看法和心得；第四，发现这本书和以前读过的其他书或文章的联系。</p><p>（1）清晰表现每一张的逻辑脉络。我习惯完全按照原书的章节给读书笔记划分章节，甚至保留各章的标题。在每一章的开头，用自己的话写下这一章作者到底想说什么，各章串起来就形成了系统。不过这种内容提要并不重要，重要的是一定要能看书作者的逻辑脉络。大多数人之所以没有真正理解一本书，就是因为看不到这个脉络。读书笔记的第一作用就是抛开故事记住文章。让一本书从厚变薄，从具体的山川景色变成抽象的地图。只有当你跳出字里行间，以居高临下的姿态俯视全章，它的脉络层次能变得清晰。看清楚以后不要抄作者的话，用自己的语言把这个脉络写出来，就好像画地图一样。</p><p>（2）带走书中所有的亮点。笔记，是我听说了一个想法之后很激动，必须把这个想法记下来据为己有的行为。所以逻辑脉络之外，如果发现真正好的小故事—我们称之为“亮点”，那么就把这个故事也写下来，甚至具体到细节。一方面，将来万一要做写文章之类的事，从笔记里翻出来就可以用。更重要的一点是这些故事日后会将反复地在我们的大脑中出现，它们用各种出其不意的方式左右我们的思想，甚至改变我们对世界的认识。你<strong>不得不承认有些段子的生命力就是比其原来所在的文章更长，以至于最后成为典故。读</strong>书，在某种程度上就是寻找能够刺激自己思维的那些亮点。我们在分析脉络的时候要忽略故事，分析完脉络再把故事带走。</p><p>（3）大量自己的看法和心得。你不可能对说得好的一句话无动于衷。你可以写下自己对这件事的理解，你还可以写下对作者的质疑或肯定。更高级的批注则是写下自己因为看到这段文字而产生的灵感。一本好书每一章都能让人迸发出10个以上的灵感。<strong>也许你突然想到这解决了你之前一直关注的问题</strong>，尽管这个问题看似与此书无关；<strong>也许你想到了对书中思想的一个新的应用；也许你想到你可以把作者的理论往前推一步。</strong>这些想法未必都真的有用，但是都非常宝贵，因为如果你不马上记下来，它们就很快被忘记。</p><p>（4）发现这本书和以前读过的其他书或文章的联系。现代人写的书，极少有一本书中的思想完全独立于世界，往往真正新的知识都建立在旧的知识之上。对着书中的观点，有没有更新的证据支持或反对这个结论？要找到他们的共同点和不同点。一个真正善于主动读书的人对这种联系是非常非常敏感的。如果你读过足够多的书，你会获得一种更难得的精力：感受人类知识的进度。你会发现一个问题在这本书里是这个说法，而过了几年之后有人另写的一本书中，引用了更有利的证据，把整个结论改变了；有时候你必须从几本书的几个不同结论中判断哪个是靠谱的；有时候你会觉得他们说的其实都不对，只有你知道正确答案。到了这个层次，你已经跟书的作者完全平等了。这时候，你进入了读书的高阶状态。读书是求知的过程，知识在转化成你对世界的理解前只是信息，对待信息，你需要有批判性思维去分辨哪些是事实，哪些是作者的观点，作者的观点是否有足够的论据支撑。看书的时候不盲从，不全盘接收，用批判性思维去评判作者的观点，建立和书籍的交互。</p><p>（5）笔记是对一本好书最大的敬意。好书之所以要读两遍，最重要的目的就是获得这些心得、灵感和联系。我们对一本不太熟悉的书，第一次读的时候我们往往会陷入作者的思想之中，我们大脑全部的带宽都被用于理解作者的思想，而没有更多的余地去产生别的想法了。“幽默是智力过剩的体现”，<strong>想法也只在带宽过剩的时候才会冒出来。</strong>只有当你读第二遍的时候，你才能气定神闲地发表意见。第一遍是为了陷进去，第二遍是为了跳出来。</p><h2 id="学习之道（11天高效入门）"><a href="#学习之道（11天高效入门）" class="headerlink" title="学习之道（11天高效入门）"></a>学习之道（11天高效入门）</h2><h4 id="自主学习者：元认知学习模型"><a href="#自主学习者：元认知学习模型" class="headerlink" title="自主学习者：元认知学习模型"></a>自主学习者：元认知学习模型</h4><h5 id="理解学习任务"><a href="#理解学习任务" class="headerlink" title="理解学习任务"></a>理解学习任务</h5><ul><li>了解需要掌握什么？</li><li>需要重现还是泛化？</li><li>你将被如何评估</li><li>拥有的时间和资源</li></ul><h5 id="制定目标"><a href="#制定目标" class="headerlink" title="制定目标"></a>制定目标</h5><ul><li>想想雄心壮志</li><li>想想要达成什么样的水平</li><li>然后把任务分成具体目标</li><li>计划何时，何地以及如何去实现这些目标</li><li>例子：研究机器学习的SVM，目标：能够很好的理解他的过程，以至于你可以向任何人解释他。为了这一目的，计划，以三个不同的来源阅读有关光合作用的资料，并且练习<strong>阐释</strong>技巧</li></ul><h5 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h5><ul><li><p>根据计划进行学习，尝试不同的学习工具</p></li><li><p>番茄钟：避免多重任务</p></li><li><p>发散模式与集中模式</p></li><li><p>主动学习： 主动回忆和阐释</p></li><li><p>交叉学习与记忆</p></li><li><p>工作记忆</p></li><li><p>3.深度学习□进行主动学习：练习主动回忆（“检索练习”）和阐释。□进行交叉学习和间隔安排学习时间。□不要一门心思去做简单的事情，要挑战自己。□保证充足的睡眠并坚持积极锻炼身体。</p></li><li><p>4.最大限度利用工作记忆</p><p>​□把学习内容分成小组块，把花哨难懂的说法换成简单的说法。□使用待办事项清单来清空你的工作记忆</p><p>5.有效记忆□使用以下记忆窍门来加速记忆：缩略语、图像和记忆宫殿。□使用隐喻来快速掌握新概念。6.获得直觉并敏捷地思考□内化（不要只是死记硬背）解决重要科学或数学问题的程序。□利用恰当的手势来帮助你记住并理解新的语言词汇。</p><p>7.发挥自律能力□想方设法在不依赖自律能力的情况下克服挑战。□从周围环境中消除诱惑、障碍和让人分心的事物。□改变你的习惯。□规划好你的目标，识别障碍并提前确定应对障碍的理想方式。</p><p>8.激励自己□提醒自己完成任务能带来的所有好处。□完成困难的任务后奖励自己。□确保任务的难度与你的技能相匹配。□设定目标：长期目标、里程碑目标和过程目标。</p><p>9.进行有效阅读□在详细阅读文本之前先对文本进行预览。□主动阅读：对文本进行思考，练习主动回忆和做批注。</p><p>9.进行有效阅读□在详细阅读文本之前先对文本进行预览。□主动阅读：对文本进行思考，练习主动回忆和做批注。</p><p>10.在考试中大获全胜□尽可能全面地了解考试相关信息并制订备考计划。□练习做以往的考试题。□在考试期间仔细阅读考试说明，把握时间进度并检查答案。□使用“硬启动”技巧。11.成为一名专业学习者□做一名拥有元认知能力的学习者：理解任务、设定目标和计划、学习、监控与调整。□从过去的经验中汲取教训：评估哪些方面进展顺利，哪些方面可以改进。</p></li></ul><h5 id="监控和调整"><a href="#监控和调整" class="headerlink" title="监控和调整"></a>监控和调整</h5><ul><li>你是否真的在进步</li><li>你是否使用最佳的学习策略</li><li>学习方式是不是合适</li></ul><h2 id="高效学习（得到版本）"><a href="#高效学习（得到版本）" class="headerlink" title="高效学习（得到版本）"></a>高效学习（得到版本）</h2><h2 id="怎么通过项目管理学习？"><a href="#怎么通过项目管理学习？" class="headerlink" title="怎么通过项目管理学习？"></a>怎么通过项目管理学习？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;学习究竟是什么？&quot;&gt;&lt;a href=&quot;#学习究竟是什么？&quot; class=&quot;headerlink&quot; title=&quot;学习究竟是什么？&quot;&gt;&lt;/a&gt;学习究竟是什么？&lt;/h2&gt;&lt;h4 id=&quot;刻意练习：&quot;&gt;&lt;a href=&quot;#刻意练习：&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Learning Method" scheme="https://hehehuang.github.io/categories/Learning-Method/"/>
    
    
  </entry>
  
  <entry>
    <title>statistics</title>
    <link href="https://hehehuang.github.io/2022/11/27/statistics/"/>
    <id>https://hehehuang.github.io/2022/11/27/statistics/</id>
    <published>2022-11-27T12:15:09.000Z</published>
    <updated>2022-11-27T12:16:43.084Z</updated>
    
    
    
    
    <category term="Math" scheme="https://hehehuang.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>probability theory</title>
    <link href="https://hehehuang.github.io/2022/11/27/probability-theory/"/>
    <id>https://hehehuang.github.io/2022/11/27/probability-theory/</id>
    <published>2022-11-27T12:14:53.000Z</published>
    <updated>2022-11-27T12:16:58.393Z</updated>
    
    
    
    
    <category term="Math" scheme="https://hehehuang.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>linear algebra</title>
    <link href="https://hehehuang.github.io/2022/11/27/linear-algebra/"/>
    <id>https://hehehuang.github.io/2022/11/27/linear-algebra/</id>
    <published>2022-11-27T12:13:39.000Z</published>
    <updated>2022-11-29T11:35:03.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>为什么学这个？</p><p>从哪里学的？</p><p>学完以后可以学什么？</p><p>向量究竟是什么？</p><p>线性组合，张成的空间与基</p><p>矩阵与线性变换</p><p>矩阵乘法与线性变换复合</p><p>三维空间中的线性变换</p><p>行列式</p><p>逆矩阵，列空间与零空间</p><p>非方阵</p><p>电积与对偶性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;为什么学这个？&lt;/p&gt;
&lt;p&gt;从哪里学的？&lt;/p&gt;
&lt;p&gt;学完以后可以学什么？&lt;/p&gt;
&lt;p&gt;向量究竟是什么？&lt;/p&gt;
&lt;p&gt;线性组合，张成</summary>
      
    
    
    
    <category term="Math" scheme="https://hehehuang.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>calculus</title>
    <link href="https://hehehuang.github.io/2022/11/27/calculus/"/>
    <id>https://hehehuang.github.io/2022/11/27/calculus/</id>
    <published>2022-11-27T12:12:49.000Z</published>
    <updated>2022-11-29T11:14:15.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为什么学这个？</p><p>从哪里学的？</p><p>学完以后可以学什么？</p><h2 id="微积分的本质"><a href="#微积分的本质" class="headerlink" title="微积分的本质"></a>微积分的本质</h2><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><h3 id="什么是导数？"><a href="#什么是导数？" class="headerlink" title="什么是导数？"></a>什么是导数？</h3><p>f(x) 在x的导数： 在x点，x的微小变化与y的微小变化之间的关系</p><p>dy&#x2F;dx</p><p>Derivatives are fundamentally about looking at tiny changes to some quantity and how that relates to a resulting tiny change in another quantity.</p><h3 id="怎么求导数？"><a href="#怎么求导数？" class="headerlink" title="怎么求导数？"></a>怎么求导数？</h3><p>y&#x3D;x*x</p><p>y+dy &#x3D; (x+dx)(x+dy)</p><p>求出 dy&#x2F;dx </p><h2 id="几何的角度看导数"><a href="#几何的角度看导数" class="headerlink" title="几何的角度看导数"></a>几何的角度看导数</h2><h4 id="假设x-x-增加了dx，-从图像中怎么看出来？"><a href="#假设x-x-增加了dx，-从图像中怎么看出来？" class="headerlink" title="假设x*x 增加了dx， 从图像中怎么看出来？"></a>假设x*x 增加了dx， 从图像中怎么看出来？</h4><p>怎么求1&#x2F;x的导数？</p><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>sinx cosx </p><p>为什么sinx的导数是cos x？</p><h2 id="链式法则和乘积法则"><a href="#链式法则和乘积法则" class="headerlink" title="链式法则和乘积法则"></a>链式法则和乘积法则</h2><h2 id="指数函数求导"><a href="#指数函数求导" class="headerlink" title="指数函数求导"></a>指数函数求导</h2><h2 id="隐函数求导是怎么回事？"><a href="#隐函数求导是怎么回事？" class="headerlink" title="隐函数求导是怎么回事？"></a>隐函数求导是怎么回事？</h2><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h2 id="积分与微积分基本定理"><a href="#积分与微积分基本定理" class="headerlink" title="积分与微积分基本定理"></a>积分与微积分基本定理</h2><h2 id="面积和斜率有什么联系"><a href="#面积和斜率有什么联系" class="headerlink" title="面积和斜率有什么联系"></a>面积和斜率有什么联系</h2><h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;为什么学这个？&lt;/p&gt;
&lt;p&gt;从哪里学的？&lt;/p&gt;
&lt;p&gt;学完以后可以学什么？&lt;/p&gt;
&lt;h2 id=&quot;微积分的本质&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Math" scheme="https://hehehuang.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>ML Introduction</title>
    <link href="https://hehehuang.github.io/2022/11/25/ML-Introduction/"/>
    <id>https://hehehuang.github.io/2022/11/25/ML-Introduction/</id>
    <published>2022-11-25T10:49:46.000Z</published>
    <updated>2022-11-25T10:52:10.318Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Machine-Learning-流程"><a href="#Machine-Learning-流程" class="headerlink" title="Machine Learning 流程"></a>Machine Learning 流程</h3><p>不同类型的Machine Learning</p><p>Linear Regression</p><p>Logistic Regression</p><p>SVM</p><p>Pertron</p><p>Byies</p><p>Decision Tree</p><p>Random Tree</p><p>Boosting </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Machine-Learning-流程&quot;&gt;&lt;a href=&quot;#Machine-Learning-流程&quot; class=&quot;headerlink&quot; title=&quot;Machine Learning 流程&quot;&gt;&lt;/a&gt;Machine Learning 流程&lt;/h3&gt;&lt;p&gt;不同</summary>
      
    
    
    
    <category term="Machine Learning" scheme="https://hehehuang.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>PythonDataStructure</title>
    <link href="https://hehehuang.github.io/2022/11/23/PythonDataStructure/"/>
    <id>https://hehehuang.github.io/2022/11/23/PythonDataStructure/</id>
    <published>2022-11-23T13:06:49.000Z</published>
    <updated>2022-11-23T13:09:55.478Z</updated>
    
    <content type="html"><![CDATA[<p>Big O</p><p>Linked list</p><p>Double Linked List</p><p>Stack</p><p>Queue</p><p>Tree</p><p>BST</p><p>HashTable</p><p>Graph</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Big O&lt;/p&gt;
&lt;p&gt;Linked list&lt;/p&gt;
&lt;p&gt;Double Linked List&lt;/p&gt;
&lt;p&gt;Stack&lt;/p&gt;
&lt;p&gt;Queue&lt;/p&gt;
&lt;p&gt;Tree&lt;/p&gt;
&lt;p&gt;BST&lt;/p&gt;
&lt;p&gt;HashTable&lt;/p&gt;
&lt;p&gt;Graph&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Python" scheme="https://hehehuang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python Advance</title>
    <link href="https://hehehuang.github.io/2022/11/21/Python-Advance/"/>
    <id>https://hehehuang.github.io/2022/11/21/Python-Advance/</id>
    <published>2022-11-21T12:37:24.000Z</published>
    <updated>2022-11-23T13:05:10.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h6 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h6><p>函数中的变量在使用完成后会被销毁。</p><p>闭包可以让你继续使用这个变量</p><h6 id="怎么构成闭包？"><a href="#怎么构成闭包？" class="headerlink" title="怎么构成闭包？"></a>怎么构成闭包？</h6><ol><li>函数嵌套</li><li>内函数使用外函数的变量</li><li>外部函数返回内部函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def outer_func(num1):</span><br><span class="line">def inner_func(num2):</span><br><span class="line">num1 = num1 + num2</span><br><span class="line">  return inner_func</span><br><span class="line">  </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h6 id="闭包的使用场景？"><a href="#闭包的使用场景？" class="headerlink" title="闭包的使用场景？"></a>闭包的使用场景？</h6><h6 id="怎么在闭包内修改外部函数变量？"><a href="#怎么在闭包内修改外部函数变量？" class="headerlink" title="怎么在闭包内修改外部函数变量？"></a>怎么在闭包内修改外部函数变量？</h6><p>nonlocal 关键词，声明外部函数变量</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><h3 id="多任务编程"><a href="#多任务编程" class="headerlink" title="多任务编程"></a>多任务编程</h3><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h3&gt;&lt;h6 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什</summary>
      
    
    
    
    <category term="Python" scheme="https://hehehuang.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Computer Composition</title>
    <link href="https://hehehuang.github.io/2022/11/05/Computer-Composition/"/>
    <id>https://hehehuang.github.io/2022/11/05/Computer-Composition/</id>
    <published>2022-11-05T13:15:20.000Z</published>
    <updated>2022-11-05T17:37:24.330Z</updated>
    
    <content type="html"><![CDATA[<h6 id="计算机硬件系统："><a href="#计算机硬件系统：" class="headerlink" title="计算机硬件系统："></a>计算机硬件系统：</h6><p>运算器+控制器+存储器+输入&#x2F;输出设备   </p><p>中央处理器</p><h6 id="什么是CPU？"><a href="#什么是CPU？" class="headerlink" title="什么是CPU？"></a>什么是CPU？</h6><p>CPU &#x3D; 运算器（数据的加工处理）+控制器（根据程序要求进行控制）</p><p>处理指令：鼠标的点击，键盘的按</p><p>运算数据：1+1 的运算</p><p>存储器：</p><p>内存储器： </p><h6 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h6><p>内存是临时存储等待CPU处理的数据，读写速度很快。</p><p>在程序运行的时候， 代码是需要在内存开辟空间来储存的。 </p><p>当内存满了以后， 电脑也就卡了。</p><p>所以，数据结构与算法就显得重要了。 </p><p>外存储器：硬盘</p><h6 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h6><p>Windows Mac Unix Linuxs</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;计算机硬件系统：&quot;&gt;&lt;a href=&quot;#计算机硬件系统：&quot; class=&quot;headerlink&quot; title=&quot;计算机硬件系统：&quot;&gt;&lt;/a&gt;计算机硬件系统：&lt;/h6&gt;&lt;p&gt;运算器+控制器+存储器+输入&amp;#x2F;输出设备   &lt;/p&gt;
&lt;p&gt;中央处理器&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Computer Composition" scheme="https://hehehuang.github.io/categories/Computer-Composition/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://hehehuang.github.io/2022/11/03/Linux/"/>
    <id>https://hehehuang.github.io/2022/11/03/Linux/</id>
    <published>2022-11-02T20:12:59.000Z</published>
    <updated>2022-11-04T15:59:17.420Z</updated>
    
    <content type="html"><![CDATA[<p>准备着：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;准备着：&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Generic C++</title>
    <link href="https://hehehuang.github.io/2022/10/28/Generic-C/"/>
    <id>https://hehehuang.github.io/2022/10/28/Generic-C/</id>
    <published>2022-10-28T10:10:16.000Z</published>
    <updated>2022-10-29T16:57:56.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><h6 id="什么是模版？"><a href="#什么是模版？" class="headerlink" title="什么是模版？"></a>什么是模版？</h6><h4 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h4><h6 id="怎么声明函数模版？"><a href="#怎么声明函数模版？" class="headerlink" title="怎么声明函数模版？"></a>怎么声明函数模版？</h6><p>两种方法</p><h6 id="怎么使用函数模版？"><a href="#怎么使用函数模版？" class="headerlink" title="怎么使用函数模版？"></a>怎么使用函数模版？</h6><h6 id="普通的函数与函数模版有什么区别？"><a href="#普通的函数与函数模版有什么区别？" class="headerlink" title="普通的函数与函数模版有什么区别？"></a>普通的函数与函数模版有什么区别？</h6><p>普通函数发生自动类型转换，（隐式类型转换）</p><p>函数模版，如果是利用自动类型推导，不会发生隐式转换， 如果是显示指定类型的方式，可以发生隐式类型转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunc&lt;int&gt;();</span><br></pre></td></tr></table></figure><h6 id="什么是隐式类型转换？"><a href="#什么是隐式类型转换？" class="headerlink" title="什么是隐式类型转换？"></a>什么是隐式类型转换？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1</span><br><span class="line">char c = &#x27;c&#x27;</span><br><span class="line">cout &lt;&lt; a + c &lt;&lt; endl; //可以得到结果100， char c 会被自动转换成相对应的ASIC码， c-99 </span><br></pre></td></tr></table></figure><p>普通函数与函数模版调用规则是什么？4点</p><ul><li>如果函数模版和普通模版都可以调用， 优先调用函数模版。</li><li>如果想强制性调用函数模版， 可以是用空模版参数列表</li><li>函数模版也可以发生函数重载</li><li>如果函数模版可以产生更好的匹配， 优先调用函数模版</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunc&lt;&gt;(a,b) //空模版参数列表</span><br></pre></td></tr></table></figure><h6 id="模版的局限性是什么？"><a href="#模版的局限性是什么？" class="headerlink" title="模版的局限性是什么？"></a>模版的局限性是什么？</h6><p>比如，传入的是自定义的Person a 与Person b 就无法对比。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt;b) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方式： 具体化 自定义的Person类： 告诉编译器 Person 怎么对比。</p><h4 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h4><h6 id="类模版的作用是什么？"><a href="#类模版的作用是什么？" class="headerlink" title="类模版的作用是什么？"></a>类模版的作用是什么？</h6><p>建立一个通用类，类中的成员数据类型可以不具体制定，而是用一个虚拟的类型来代表。</p><h6 id="类模版的语法是什么？"><a href="#类模版的语法是什么？" class="headerlink" title="类模版的语法是什么？"></a>类模版的语法是什么？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模版与函数模版的区别是什么？</p><ul><li>类模版没有自动类型推导的使用方式</li><li>类模版在模版参数列表中可以有默认参数</li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h6 id="什么是STL？"><a href="#什么是STL？" class="headerlink" title="什么是STL？"></a>什么是STL？</h6><p>standard template library</p><p>STL 广义上能分成几大部分？</p><p>三大部分：容器（container）算法（algorithm）迭代器（iterator） </p><h6 id="STL-六大组件是什么？"><a href="#STL-六大组件是什么？" class="headerlink" title="STL 六大组件是什么？"></a>STL 六大组件是什么？</h6><p>容器，算法，</p><p>迭代器：算法与容器之间想要有交流必须通过迭代器</p><p>仿函数：行为类似函数</p><p>适配器（配接器）：比如有些算法只接收一个参数，通过适配器， 就可以使之接收多个算法</p><p>空间配置器：负责空间的配置与管理</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h6 id="容器指的是哪些？"><a href="#容器指的是哪些？" class="headerlink" title="容器指的是哪些？"></a>容器指的是哪些？</h6><p>Vector，list，duque, set, map 用来存放数据</p><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><h6 id="什么是Vector？"><a href="#什么是Vector？" class="headerlink" title="什么是Vector？"></a>什么是Vector？</h6><p>动态数组，可以储存一个能够存放任意类型的动态数组，能够增加和压缩数据。</p><p>vector 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。</p><p>是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h6 id="什么是String？"><a href="#什么是String？" class="headerlink" title="什么是String？"></a>什么是String？</h6><p>char * 是指针。 String 本质上是一个类，Char* 型的容器</p><p>序列式容器：</p><p>强调值的排序，序列式容器中的每个元素均有固定的位置。</p><p>关联式容器：</p><p>二叉树的结构，各元素之间没有严格上物理上的顺序关系。</p><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><p>质变算法</p><p>运算过程中会改变区间内的元素的内容。如：拷贝，替换，删除</p><p>非质变算法</p><p>运算过程中不会更改区间内的元素内容，例如查找，计数，遍历，寻找极值</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>提供一种方法，能够依次序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><h3 id="适配器（配接器）"><a href="#适配器（配接器）" class="headerlink" title="适配器（配接器）"></a>适配器（配接器）</h3><h3 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型编程&quot;&gt;&lt;a href=&quot;#泛型编程&quot; class=&quot;headerlink&quot; title=&quot;泛型编程&quot;&gt;&lt;/a&gt;泛型编程&lt;/h2&gt;&lt;h3 id=&quot;模版&quot;&gt;&lt;a href=&quot;#模版&quot; class=&quot;headerlink&quot; title=&quot;模版&quot;&gt;&lt;/a&gt;模版&lt;/h</summary>
      
    
    
    
    <category term="C++" scheme="https://hehehuang.github.io/categories/C/"/>
    
    
    <category term="Generic Programming" scheme="https://hehehuang.github.io/tags/Generic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>FGBA</title>
    <link href="https://hehehuang.github.io/2022/10/27/FGBA/"/>
    <id>https://hehehuang.github.io/2022/10/27/FGBA/</id>
    <published>2022-10-27T13:48:32.000Z</published>
    <updated>2022-10-29T17:18:52.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FGBA"><a href="#FGBA" class="headerlink" title="FGBA"></a>FGBA</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;FGBA&quot;&gt;&lt;a href=&quot;#FGBA&quot; class=&quot;headerlink&quot; title=&quot;FGBA&quot;&gt;&lt;/a&gt;FGBA&lt;/h2&gt;</summary>
      
    
    
    
    <category term="FGBA" scheme="https://hehehuang.github.io/categories/FGBA/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ Basic</title>
    <link href="https://hehehuang.github.io/2022/10/23/C-Basic/"/>
    <id>https://hehehuang.github.io/2022/10/23/C-Basic/</id>
    <published>2022-10-23T08:57:04.000Z</published>
    <updated>2022-10-29T16:35:32.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-基础："><a href="#C-基础：" class="headerlink" title="C++ 基础："></a>C++ 基础：</h2><p>函数：</p><h6 id="什么是函数分文件？为什么要分文件编写？"><a href="#什么是函数分文件？为什么要分文件编写？" class="headerlink" title="什么是函数分文件？为什么要分文件编写？"></a>什么是函数分文件？为什么要分文件编写？</h6><p>让代码结构更加清晰，在头文件中写函数的声明，在源文件中写函数的定义。</p><p>指针：</p><h6 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h6><p>内存编号是从0开始的，一般用十六进制数字表示</p><p>可以利用指针变量保存地址。</p><h6 id="指针的作用是什么？"><a href="#指针的作用是什么？" class="headerlink" title="指针的作用是什么？"></a>指针的作用是什么？</h6><p>可以通过指针间接的访问内存</p><h6 id="指针怎么通过保存的地址，拿到对应的值？"><a href="#指针怎么通过保存的地址，拿到对应的值？" class="headerlink" title="指针怎么通过保存的地址，拿到对应的值？"></a>指针怎么通过保存的地址，拿到对应的值？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义指针</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 数据类型 * 指针变量名</span></span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line"><span class="comment">//让指针记录变量a的地址</span></span><br><span class="line">p = &amp;a;  <span class="comment">//&amp;取址符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过解引用的方式来找到 指针指向的内存</span></span><br><span class="line">*p </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="指针也是数据类型，那么它占用多少内存空间？"><a href="#指针也是数据类型，那么它占用多少内存空间？" class="headerlink" title="指针也是数据类型，那么它占用多少内存空间？"></a>指针也是数据类型，那么它占用多少内存空间？</h6><p>4 字节， 在32位操作系统下。8个字节，在64位操作系统下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof(int *);</span><br><span class="line">sizeof(char *);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="什么是空指针？"><a href="#什么是空指针？" class="headerlink" title="什么是空指针？"></a>什么是空指针？</h6><p>指针变量指向了编号为0的空间。</p><p>用途： 初始化指针变量。</p><p>空指针指向的内存不可访问， 内存编号0～255 是系统占用内存，用户访问不了</p><h6 id="什么是野指针？"><a href="#什么是野指针？" class="headerlink" title="什么是野指针？"></a>什么是野指针？</h6><p>指针变量指向了非法的内存空间。</p><h6 id="什么是const修饰指针？"><a href="#什么是const修饰指针？" class="headerlink" title="什么是const修饰指针？"></a>什么是const修饰指针？</h6><p>常量指针</p><p>特点：指针的指向可以修改，但是指针指向的值不可以改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * p = &amp;a; <span class="comment">//常量指针</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指针常量</p><p>特点： 指针的指向不可以改，但指针指向的值可以改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure><p>const 即修饰指针，又修饰常量</p><p>特点：指针的指向跟指针指向的值都不可以改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure><h6 id="怎么利用指针来访问数组？"><a href="#怎么利用指针来访问数组？" class="headerlink" title="怎么利用指针来访问数组？"></a>怎么利用指针来访问数组？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int arr[3] = &#123;1,2,3&#125;;</span><br><span class="line">int * p = arr; //arr 是数组第一个元素的首地址</span><br><span class="line">p++； //指针向后偏移了4个字节</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怎么利用指针作为函数的参数来修改实参的值？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void swap(int *p1, int *p2)&#123;</span><br><span class="line">  int temp = *p;</span><br><span class="line">  *p1 = *p2;</span><br><span class="line">  *p2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存模型："><a href="#内存模型：" class="headerlink" title="内存模型："></a>内存模型：</h4><h6 id="内存在C-程序在执行时，-都分成了那几个区域？"><a href="#内存在C-程序在执行时，-都分成了那几个区域？" class="headerlink" title="内存在C++程序在执行时， 都分成了那几个区域？"></a>内存在C++程序在执行时， 都分成了那几个区域？</h6><p>代码区，存放函数体的二进制代码</p><p>全局区，存放全局变量和静态变量以及常量</p><p>栈区，有编译器自动分配释放，存放函数的参数值，局部变量</p><p>堆区： 由程序员分配和释放， 若程序员不释放， 程序结束，由操作系统回收</p><h6 id="new-操作符是什么？"><a href="#new-操作符是什么？" class="headerlink" title="new 操作符是什么？"></a>new 操作符是什么？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">//利用new创建的数据，会返回该数据对应的类型的指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数指针：</p><p> 如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>&#123;...&#125; <span class="comment">//这个函数返回 指针</span></span><br><span class="line"><span class="type">int</span> （*func1）(<span class="type">int</span> ,<span class="type">int</span>) &#123; ...&#125; <span class="comment">// 这个是函数指针</span></span><br></pre></td></tr></table></figure><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><h6 id="什么是引用？"><a href="#什么是引用？" class="headerlink" title="什么是引用？"></a>什么是引用？</h6><p>给变量起别名。</p><p>引用必须初始化， 引用在初始化后，不可以改变。</p><p>引用的本质是指针常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">//引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">//指针</span></span><br></pre></td></tr></table></figure><h6 id="引用，值传递，地址传递-之间的区别是什么？"><a href="#引用，值传递，地址传递-之间的区别是什么？" class="headerlink" title="引用，值传递，地址传递 之间的区别是什么？"></a>引用，值传递，地址传递 之间的区别是什么？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> <span class="comment">//这里的形参的a 就是实参的a， 别名跟原名可以是一样的。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap03</span>(a,b) </span><br></pre></td></tr></table></figure><p>引用做函数返回值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C-面向对象："><a href="#C-面向对象：" class="headerlink" title="C++面向对象："></a>C++面向对象：</h2><h3 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h3><blockquote><p>将属性和行为结合在一起模拟事物， 还设置了访问权限。</p></blockquote><p>访问权限：public， protected，private </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    string name</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string Name)</span></span>&#123;</span><br><span class="line">      name = Name;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Name&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p1;</span><br><span class="line">  p1.<span class="built_in">setName</span>(<span class="string">&quot;HH&quot;</span>);</span><br><span class="line">  p1.<span class="built_in">showName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的初始化和清理："><a href="#对象的初始化和清理：" class="headerlink" title="对象的初始化和清理："></a>对象的初始化和清理：</h3><p>为什么有： 安全温习</p><h4 id="析构函数（）："><a href="#析构函数（）：" class="headerlink" title="析构函数（）："></a>析构函数（）：</h4><blockquote><p>消除对象</p></blockquote><h4 id="构造函数（）："><a href="#构造函数（）：" class="headerlink" title="构造函数（）："></a>构造函数（）：</h4><blockquote><p>构造初始属性，创建对象时，为对象成员属性赋值，比如工厂里面的出场设置。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="built_in">Person</span>()&#123;&#125; </span><br><span class="line">  ~<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数来划分：</p><p>有参构造函数</p><p>无参构造函数</p><p>类型来划分：</p><p>普通构造</p><p>拷贝构造:</p><p>拷贝构造函数调用时机：</p><ol><li><p>使用一个已经创建完毕的对象来初始化一个新对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = Person(10);</span><br><span class="line">Person p2 = p1;</span><br></pre></td></tr></table></figure></li><li><p>值传递的方式给函数参数传值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void doWork(p)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">doWork(p); //此处的p， 并不是上面的p对象， 而是拷贝函数构造的一个副本。 值传递的本质就是复制出一个副本。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>值方式返回局部对象</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//方法</span><br><span class="line">Person doWork2()&#123;</span><br><span class="line">Person p1; //匿名对象</span><br><span class="line">return p1; // return 的并不是 p1 的匿名对象， 而是一个副本。 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法：</p><p>括号法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//无参构造</span><br><span class="line">//有参构造</span><br><span class="line">//拷贝构造</span><br></pre></td></tr></table></figure><p><strong>Notice：调用默认构造函数时候，不要加（）</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为什么不要加（）</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">()</span></span>; <span class="comment">//编译器会以为这是一个函数声明。 创造一个 函数名为p1，返回Person类型的函数，不会认为是创建对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure><p>显示法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1;</span><br><span class="line">Person p2 = Person（<span class="number">10</span>）;<span class="comment">// 单看 Person（10） 是匿名对象。后将匿名对象赋予person p2</span></span><br><span class="line">Person（<span class="number">10</span>）;<span class="comment">//这行代码一执行完， 匿名对象就会被清除 </span></span><br></pre></td></tr></table></figure><p>隐式转换法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p4 = 10;</span><br><span class="line">Person p4 = Person(10); </span><br><span class="line">Person p5 = p4;</span><br><span class="line">Person p5 = Person(p4);</span><br></pre></td></tr></table></figure><h5 id="构造函数的调用规则："><a href="#构造函数的调用规则：" class="headerlink" title="构造函数的调用规则："></a>构造函数的调用规则：</h5><h6 id="默认情况下，创造一个类，-C-编译器会至少给你添加哪三个函数？"><a href="#默认情况下，创造一个类，-C-编译器会至少给你添加哪三个函数？" class="headerlink" title="默认情况下，创造一个类， C++编译器会至少给你添加哪三个函数？"></a>默认情况下，创造一个类， C++编译器会至少给你添加哪三个函数？</h6><p>调用规则：</p><h6 id="如果用户自定义了有参数构造函数，会发生什么？"><a href="#如果用户自定义了有参数构造函数，会发生什么？" class="headerlink" title="如果用户自定义了有参数构造函数，会发生什么？"></a>如果用户自定义了有参数构造函数，会发生什么？</h6><h6 id="如果用户自定义了拷贝构造函数，会发生什么？"><a href="#如果用户自定义了拷贝构造函数，会发生什么？" class="headerlink" title="如果用户自定义了拷贝构造函数，会发生什么？"></a>如果用户自定义了拷贝构造函数，会发生什么？</h6><h5 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h5><h6 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h6><h6 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h6><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><h6 id="初始化列表有什么作用？"><a href="#初始化列表有什么作用？" class="headerlink" title="初始化列表有什么作用？"></a>初始化列表有什么作用？</h6><h6 id="初始化列表的语法？"><a href="#初始化列表的语法？" class="headerlink" title="初始化列表的语法？"></a>初始化列表的语法？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//传统的初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用初始化列表</span><br><span class="line"></span><br><span class="line">Person():m_a(10),m_b(20),m_c(30)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(int a, int b ,int c):m_a(a),m_b(b),m_c(c)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h5><h6 id="什么是对象成员？"><a href="#什么是对象成员？" class="headerlink" title="什么是对象成员？"></a>什么是对象成员？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h6 id="当B类中有A类的对象时，在创建B类对象时，-构造函数与析构函数分别是怎么调用的？"><a href="#当B类中有A类的对象时，在创建B类对象时，-构造函数与析构函数分别是怎么调用的？" class="headerlink" title="当B类中有A类的对象时，在创建B类对象时， 构造函数与析构函数分别是怎么调用的？"></a>当B类中有A类的对象时，在创建B类对象时， 构造函数与析构函数分别是怎么调用的？</h6><p>先构造A类对象，再构造B类对象</p><p>先析构B类对象，再析构A类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br></pre></td></tr></table></figure><h5 id="静态成员："><a href="#静态成员：" class="headerlink" title="静态成员："></a>静态成员：</h5><h6 id="静态成员的作用？"><a href="#静态成员的作用？" class="headerlink" title="静态成员的作用？"></a>静态成员的作用？</h6><h6 id="静态成员变量有什么特点？"><a href="#静态成员变量有什么特点？" class="headerlink" title="静态成员变量有什么特点？"></a>静态成员变量有什么特点？</h6><h6 id="静态成员函数有什么特点？"><a href="#静态成员函数有什么特点？" class="headerlink" title="静态成员函数有什么特点？"></a>静态成员函数有什么特点？</h6><h6 id="有哪两种调用静态成员函数的方式？"><a href="#有哪两种调用静态成员函数的方式？" class="headerlink" title="有哪两种调用静态成员函数的方式？"></a>有哪两种调用静态成员函数的方式？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="C-对象模型和this指针："><a href="#C-对象模型和this指针：" class="headerlink" title="C++ 对象模型和this指针："></a>C++ 对象模型和this指针：</h3><h4 id="成员变量和成员函数"><a href="#成员变量和成员函数" class="headerlink" title="成员变量和成员函数"></a>成员变量和成员函数</h4><h6 id="在C-中，类内的成员变量和成员函数怎么分开存储？"><a href="#在C-中，类内的成员变量和成员函数怎么分开存储？" class="headerlink" title="在C++中，类内的成员变量和成员函数怎么分开存储？"></a>在C++中，类内的成员变量和成员函数怎么分开存储？</h6><p>空对象占体格内存空间：1 它有着一个独一无二的内存地址</p><p>静态成员变量或者函数， 都不属于类对象上</p><p>非静态成员变量属于类的对象上。</p><p>非静态成员函数不属于类的对象上， 每一个非静态成员的都只会诞生一份函数实例， 也就是说 多个同类型的对象会共用同一块代码。</p><h6 id="怎么区分是哪个对象调用了自己？"><a href="#怎么区分是哪个对象调用了自己？" class="headerlink" title="怎么区分是哪个对象调用了自己？"></a>怎么区分是哪个对象调用了自己？</h6><p>this 指针：指向 被调用的成员函数所属的对象</p><p>this 指针的用途是什么？</p><ul><li>当形参和成员变量同名时，可用this 指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><h3 id="友元："><a href="#友元：" class="headerlink" title="友元："></a>友元：</h3><h6 id="友元的目的是什么？"><a href="#友元的目的是什么？" class="headerlink" title="友元的目的是什么？"></a>友元的目的是什么？</h6><p>让一个函数或者类访问另一个类中私有成员</p><h3 id="运算符重载："><a href="#运算符重载：" class="headerlink" title="运算符重载："></a>运算符重载：</h3><h6 id="运算符重载的作用？"><a href="#运算符重载的作用？" class="headerlink" title="运算符重载的作用？"></a>运算符重载的作用？</h6><p>对于内置数据类型，编译器知道如何运算。 </p><p>但自定义数据类型，编译器就不知道怎么运算了。</p><p>加号运算符重载：</p><p>operator+ : 编译器给了一个通用名</p><h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>拥有上一级的共性，还有自己的特性。</p><h6 id="继承的基本语法："><a href="#继承的基本语法：" class="headerlink" title="继承的基本语法："></a>继承的基本语法：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>: access-specifier base-<span class="keyword">class</span></span><br></pre></td></tr></table></figure><p>自身场景的应用：</p><p>网页中， 公共的头部，公共的底部，只有中心内容不一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasedPage</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasedPage&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>: <span class="keyword">public</span> BasedPage&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="有哪三种继承方式？"><a href="#有哪三种继承方式？" class="headerlink" title="有哪三种继承方式？"></a>有哪三种继承方式？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h6 id="从父类继承过来的成员，哪些属于子类对象中的？"><a href="#从父类继承过来的成员，哪些属于子类对象中的？" class="headerlink" title="从父类继承过来的成员，哪些属于子类对象中的？"></a>从父类继承过来的成员，哪些属于子类对象中的？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>子类继承父类后，当创建子类对象是，会调用父类的构造函数。</p><h6 id="子类父类的构造函数的顺序是？"><a href="#子类父类的构造函数的顺序是？" class="headerlink" title="子类父类的构造函数的顺序是？"></a>子类父类的构造函数的顺序是？</h6><p>先Base构造函数，在Son构造函数， 后Son析构函数，再base的析构函数</p><h6 id="当父类与子类有同名成员，怎么通过子类对象，来访问子类或者父类的数据？"><a href="#当父类与子类有同名成员，怎么通过子类对象，来访问子类或者父类的数据？" class="headerlink" title="当父类与子类有同名成员，怎么通过子类对象，来访问子类或者父类的数据？"></a>当父类与子类有同名成员，怎么通过子类对象，来访问子类或者父类的数据？</h6><p>子类同名成员，直接访问</p><p>父类同名成员，加作用域</p><p>Notice：<strong>如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类所有同名成员函数，如果想要访问父类的同名成员，需要加上作用域</strong></p><p>静态成员同名</p><p>多继承</p><p>菱形继承</p><h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><p>多态的基本概念：</p><p>子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现</p><p>什么是对象切割？ </p><p>多态的底层原理是什么？ </p><p>纯虚函数和抽象类</p><h6 id="纯虚函数的作用是什么？"><a href="#纯虚函数的作用是什么？" class="headerlink" title="纯虚函数的作用是什么？"></a>纯虚函数的作用是什么？</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h6 id="什么是抽象类？"><a href="#什么是抽象类？" class="headerlink" title="什么是抽象类？"></a>什么是抽象类？</h6><h6 id="抽象类有什么特点？"><a href="#抽象类有什么特点？" class="headerlink" title="抽象类有什么特点？"></a>抽象类有什么特点？</h6><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p>虚析构和纯虚析构</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-基础：&quot;&gt;&lt;a href=&quot;#C-基础：&quot; class=&quot;headerlink&quot; title=&quot;C++ 基础：&quot;&gt;&lt;/a&gt;C++ 基础：&lt;/h2&gt;&lt;p&gt;函数：&lt;/p&gt;
&lt;h6 id=&quot;什么是函数分文件？为什么要分文件编写？&quot;&gt;&lt;a href=&quot;#什么是函数分文</summary>
      
    
    
    
    <category term="C++" scheme="https://hehehuang.github.io/categories/C/"/>
    
    
    <category term="OOP" scheme="https://hehehuang.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Recommender System</title>
    <link href="https://hehehuang.github.io/2022/09/29/Recommender-System/"/>
    <id>https://hehehuang.github.io/2022/09/29/Recommender-System/</id>
    <published>2022-09-29T12:38:48.000Z</published>
    <updated>2022-09-29T12:39:42.839Z</updated>
    
    
    
    
    <category term="Big Data" scheme="https://hehehuang.github.io/categories/Big-Data/"/>
    
    
    <category term="PySpark" scheme="https://hehehuang.github.io/tags/PySpark/"/>
    
  </entry>
  
  <entry>
    <title>Data Science</title>
    <link href="https://hehehuang.github.io/2022/09/29/Data-Science/"/>
    <id>https://hehehuang.github.io/2022/09/29/Data-Science/</id>
    <published>2022-09-28T19:10:26.000Z</published>
    <updated>2022-10-14T18:22:57.274Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Statistics</p><ul><li>Descriptive Statistic<ul><li>Visualization of data</li></ul></li><li>Inferential Statistics<ul><li>One sample test of difference&#x2F;One sample hypothesis test.</li><li>Confidence Interval</li><li>Contingency Tables and Chi Square Statistic</li><li>T-test or Anova</li><li>Pearson Correlation</li><li>Bi-variate Regression</li><li>Multi-variate Regression</li></ul></li></ul></li><li><p>Probability</p><ul><li><p>Random variable</p></li><li><p>Discrete variable </p></li><li><p>Continous variable</p></li></ul></li><li><h2 id="Line-Algebra"><a href="#Line-Algebra" class="headerlink" title="Line Algebra"></a>Line Algebra</h2></li><li><p>Calculus</p></li><li><p>Optimization</p><ul><li>Gradient descent</li></ul></li><li><p>Python</p><ul><li>Python Basic</li><li>Python Advance</li><li>Algorithm</li><li>Visualization</li></ul></li><li><p>Web Scraping</p></li><li><p>Machine Learning</p><ul><li><p>Superivor Learning</p><ul><li><p>Regression</p></li><li><p>Classification</p></li></ul></li><li><p>Unsuperivor Learning</p><ul><li>Clusting</li></ul></li></ul></li><li><p>Deep Learning</p><ul><li>DNN</li><li>CNN</li></ul></li><li><p>NLP</p></li><li><p>Computer Vision</p></li><li><p>Data Mining</p><ul><li>Network Analysis</li><li>Recommender System</li></ul></li><li><p>Big Data </p><ul><li>Batching Processing<ul><li>Hadoop</li><li>Spark</li><li>Hive</li><li>Kafka</li><li>Flink</li><li>Reids</li></ul></li><li>Stream Processing</li></ul></li><li><p>SQL</p><ul><li>Relation SQL</li><li>NOSQL</li></ul></li><li><p>AWS</p></li><li><p>Docker &amp; K8s </p></li><li><p>Python GUI</p></li><li><p>Web Development</p></li><li><p>fundatmetals</p></li><li><p>statistics</p></li><li><p>programming</p></li><li><p>machine learning</p></li><li><p>text ming&#x2F;nlp</p></li><li></li><li><p>big data</p></li><li><p>data ingestion</p></li><li><p>data munging</p></li><li><p>Tool box</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Statistics&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Descriptive Statistic&lt;ul&gt;
&lt;li&gt;Visualization of data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Inferential Statistics&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spark ML Case</title>
    <link href="https://hehehuang.github.io/2022/09/26/Spark-ML-Case/"/>
    <id>https://hehehuang.github.io/2022/09/26/Spark-ML-Case/</id>
    <published>2022-09-26T09:21:53.000Z</published>
    <updated>2022-09-26T09:21:53.804Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>NLP for DeepLearning</title>
    <link href="https://hehehuang.github.io/2022/09/24/NLP-for-DeepLearning/"/>
    <id>https://hehehuang.github.io/2022/09/24/NLP-for-DeepLearning/</id>
    <published>2022-09-24T10:29:33.000Z</published>
    <updated>2022-10-14T18:17:53.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DNN"><a href="#DNN" class="headerlink" title="DNN"></a>DNN</h3><p>CNN</p><p>RNN</p><p>LSTM</p><p>Sequence to Sequence</p><p>BERT</p><p>1. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DNN&quot;&gt;&lt;a href=&quot;#DNN&quot; class=&quot;headerlink&quot; title=&quot;DNN&quot;&gt;&lt;/a&gt;DNN&lt;/h3&gt;&lt;p&gt;CNN&lt;/p&gt;
&lt;p&gt;RNN&lt;/p&gt;
&lt;p&gt;LSTM&lt;/p&gt;
&lt;p&gt;Sequence to Sequence&lt;/p&gt;
&lt;p&gt;BERT</summary>
      
    
    
    
    <category term="NLP" scheme="https://hehehuang.github.io/categories/NLP/"/>
    
    
    <category term="Deep Learning" scheme="https://hehehuang.github.io/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>English Weekly Plan</title>
    <link href="https://hehehuang.github.io/2022/09/24/English-Weekly-Plan/"/>
    <id>https://hehehuang.github.io/2022/09/24/English-Weekly-Plan/</id>
    <published>2022-09-24T09:45:12.000Z</published>
    <updated>2022-09-30T12:05:06.565Z</updated>
    
    <content type="html"><![CDATA[<h4 id="THINGS-YOU-WILL-NEED"><a href="#THINGS-YOU-WILL-NEED" class="headerlink" title="THINGS YOU WILL NEED:"></a>THINGS YOU WILL NEED:</h4><ul><li>1 hour per day (30 minutes will work as well).</li><li>a notebook and a pen to write down new vocabulary each day.</li><li>an English song.</li><li>an English a book.</li><li>an English TV show.</li></ul><h4 id="MONDAYS"><a href="#MONDAYS" class="headerlink" title="MONDAYS"></a>MONDAYS</h4><p>(Spend 30-40 minutes Reading)</p><ul><li>Read your book.</li><li>Read the news.</li><li>Read an article on <a href="http://simple.wikipedia.com/">http://simple.wikipedia.com</a></li><li>Write down some new words in your notebook with their definition.</li><li>Spend the rest of your hour:<br> – Reading out loud from your book<br> – Writing out some passages from your book.<br> – Listening to the audiobook of your book.<br> – Using Duolingo or other learning apps.</li></ul><h4 id="TUESDAYS"><a href="#TUESDAYS" class="headerlink" title="TUESDAYS"></a>TUESDAYS</h4><p>(Spend 30-40 minutes Writing)</p><ul><li>Write what you did yesterday, today, and tomorrow in your notebook.</li><li>Write a few comments on Youtube videos.</li><li>Write some sentences about what you like and dislike about your song, your book, and your TV show.</li><li>Write a summary of what you have read in your book the day before.</li><li>Put some new words in your dictionary.</li><li>Spend the rest of your hour:<br> – Reading what you have written.<br> – Listening to what you have written by pasting your writing into Google translate and have it read it to you.<br> – Reading what you have written out loud.<br> – Using Duolingo or other learning apps.</li></ul><h4 id="WEDNESDAYS"><a href="#WEDNESDAYS" class="headerlink" title="WEDNESDAYS"></a>WEDNESDAYS</h4><p>(Spend 30-40 minutes Listening):</p><ul><li>Watch your TV show.</li><li>Listen to your song.</li><li>Listen to the Audiobook of your book if you have it.</li><li>Watch a few Youtube videos.</li><li>Put new words in your dictionary.</li><li>Spend the rest of your hour:<br> – Read about your TV show.<br> – Write about how your song makes you feel.<br> – Mimic or shadow people from your TV show.<br> – Sing along to your song.</li></ul><h4 id="THURSDAYS"><a href="#THURSDAYS" class="headerlink" title="THURSDAYS"></a>THURSDAYS</h4><p>(Spend 30-40 minutes Speaking):</p><ul><li>Hire a tutor on:<br> – Preply: <a href="http://tracking.preply.com/SH2X">http://tracking.preply.com/SH2X</a><br> – Cambly: <a href="http://cambly.com/">http://cambly.com</a><br> – iTalki: <a href="http://italki.com/">http://italki.com</a></li><li>Talk out loud.</li><li>Narrate your life.</li><li>Record yourself and play it back.</li><li>Put words in your dictionary.</li><li>Spend the rest of your hour:<br> – Reading out loud.<br> – Singing out loud.<br> – Shadowing or mimicking actors from your TV show.</li></ul><h4 id="FRIDAYS"><a href="#FRIDAYS" class="headerlink" title="FRIDAYS"></a>FRIDAYS</h4><p>(Spend the Entire hour on Vocabulary):</p><ul><li>Review all the words in your dictionary.</li><li>Write them out.</li><li>Say them out loud.</li><li>Use them in a sentence.</li><li>Make a <a href="http://quizlet.com/">http://quizlet.com</a> set.</li><li>Make flashcards.</li><li>Work until you have them all memorized.</li></ul><h4 id="WEEKENDS"><a href="#WEEKENDS" class="headerlink" title="WEEKENDS:"></a>WEEKENDS:</h4><ul><li>Find a new song.</li><li>Find a new book.</li><li>Find a new TV show.</li><li>Take a break.</li></ul><h4 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h4><p><a href="https://www.youtube.com/watch?v=5-T6Xqlh6BU&amp;t=283s">https://www.youtube.com/watch?v=5-T6Xqlh6BU&amp;t=283s</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;THINGS-YOU-WILL-NEED&quot;&gt;&lt;a href=&quot;#THINGS-YOU-WILL-NEED&quot; class=&quot;headerlink&quot; title=&quot;THINGS YOU WILL NEED:&quot;&gt;&lt;/a&gt;THINGS YOU WILL NEED:&lt;/h4</summary>
      
    
    
    
    <category term="English" scheme="https://hehehuang.github.io/categories/English/"/>
    
    
  </entry>
  
</feed>
